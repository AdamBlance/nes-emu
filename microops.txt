Instead of a state machine or encoding in one big match, I wonder if I could break each instruction
into its micro-ops and execute them? 

When the emulator starts up, it could decompose all instructions in program ROM into their micro-ops
and then run the emulator on these instead. Code can run from anywhere in memory, and some games 
apparently do this, so I'll need to dynamically generate new micro-op code if the program counter 
goes out of a certain range. 

The CPU can execute multiple micro-ops per cycle. Will either need to find a way to tell a micro-op 
not to advance the cycle counter, or determine if there is a small-ish set of micro-ops that do 
two things at once that I can give their own unique micro-opcodes.

Micro-ops that do two things at once:

fetch opcode/byte2/byte3, increment pc
push high pc on stack, decrement stack pointer
push low pc on stack, decrement stack pointer
push status register on stack, decrement stack pointer

pull status register from stack, increment stack pointer
pull low pc from stack, increment stack pointer

push register on stack, decrement stack pointer

copy low address byte to program counter low, fetch high address byte and put in pc

write byte to effective address, do operation on it (this is like, 12 instructions)

What sort of data structure should be used for this? The maximum number of cycles for an instruction
is 8, but I think I'll need more than that honestly for the double ops. 

The naive way would be to use a 2D array, with the height being the maximum number of micro-ops in 
an instruction. This seems like a massive waste of memory though. Modern CPU cache is ginormous 
though so it's probably fine... Don't know how that will affect cache though. 

Even if the depth was 16, that's only (2^16)*16 = 1MB. 3700X has 32MB of L3 cache. Plus, most of
that isn't going to be in use anyway. Could always do some variable depth thing later down the line,
but that's probably going to introduce indirection which might outweigh any memory savings. 


