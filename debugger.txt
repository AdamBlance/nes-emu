Debugger required features:

 - CPU 
    + show current instruction + detail (addressing mode, target value, etc)
    + show register state
    + show interrupt status (edge detectors and pending state)
    + show cycle by cycle breakdown of what an instruction does
 - PPU
    + show scanline, cycle, with pixel-by-pixel rendering
    + show NMI state (in_vblank, the other bit, the NMI line)
    + show pattern table, nametable, attribute table
    + show which pattern tile is being pointed to by nametable
    + show which palette is being pointed to by attribute table
    + show shift registers, and temporary latches 
    + show OAM stuff
    + show mapper specific information
    + show v, how it gets transformed to get the pattern table, nametable, palette values
    + PPUDATA bus
    + show a zoomed in, pixel-by-pixel view as the image is being drawn
    + show optional tile and attribute table boundaries
- APU 
    + show all counters
    + show derived pitch values, approximate note
- RAM
    + show recent reads and writes
    + show different areas of memory
    + explicitly show mirroring
    + show mapper communication
- Control Flow
    + run for one CPU cycle, one PPU cycle, one frame, one scanline, etc
    + run until condition
        - vblank
        - rendering enabled/disabled
        - memory read/write
        - a certain instruction is hit? 
        - register changes
        - interrupt
    + detect and jump over long loops that init memory or wait for vblank
    + allow subroutines to be annotated? could save to a file
    + show value at previous cycle above each value in small font? 
    + Have a step-back feature with limited range, maybe a few frames? Could store the changes in 
      state between cycles, although might be easier to just take a snapshot of entire system 
      periodically and then delta from there? 
    + run at a very slow speed with the debugger still open, like 1-100 instructions/s so you don't
      have to constantly something, could just hold a key or button to do this
- Misc
    + have a little box with text that pings when obscure behaviour happens and gives an explanation
    + have an NES controller with buttons that you can click on to send input at next cycle


If you're coming back to this, a good place to start I think is the CPU. 
Try to get literally every test you can think of passing. 
So implement every single unofficial opcode. 
Also do a little review of how the interrupt stuff is working.
Might be nice to create a (mostly) exhaustive flowchart.
Also, try not to get stuck on refactoring. Focus on just implementing all the opcodes. 

Test roms passed:
    branch_timing_tests
    cpu_dummy_reads



    [ByteCode,10][Disassembly][EffectiveAddress] [MemoryValue,h][Align,50] A:[A,2h] X:[X,2h] Y:[Y,2h] P:[P,2h] SP:[SP,2h] PPU:[Scanline],[Cycle] CYC:[CycleCount]

    [ByteCode,10][Disassembly][EffectiveAddress] [Align,50] A:[A,2h] X:[X,2h] Y:[Y,2h] P:[P,2h] SP:[SP,2h] PPU:[Scanline],[Cycle] CYC:[CycleCount]